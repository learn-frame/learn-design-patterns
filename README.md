# 学习设计模式 (JavaScript version)

## Motivations

何为设计模式?

> 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案, 设计模式的主题总是把不变的事物和变化的事物分离开来.

为什么要学设计模式呢?

为了能写出可维护, 高质量的代码? 准备读 react 源码了, 各种观察者模式, 代理模式看不懂?

大抵如此吧, 也许短时间看不出什么效果, 但内心深处一直觉得学习它有深远的意义.

或许时间会给予答案.

最后以鲁迅先生的原话做结, 共勉之.

> (1) 没学设计模式前一点也不懂, 根本想不到设计模式, 设计的代码很糟糕.
>
> (2) 学了几个设计模式后, 很开心, 于是到处想着要用自己学过的模式, 于是时常造成误用模式而不知.
>
> (3) 学完全部模式时, 感觉诸多的设计模式极为相似, 无法分清设计模式之间的差异, 有困惑, 但深知误用之害, 应用之时有所犹豫.
>
> (4) 灵活应用模式, 甚至不应用具体的某种模式也能设计出优秀的代码, 以达到无剑胜有剑的境界.

## 设计模式 6 大原则(SOLID)

总原则 - 开闭原则(Open Closed Principle)

> 一个软件实体, 如类, 模块和函数应该对扩展开放, 对修改关闭.

在程序需要进行拓展的时候, 不能去修改原有的代码, 而是要扩展原有代码, 实现一个热插拔的效果. 所以一句话概括就是: 为了使程序的扩展性好, 易于维护和升级.

想要达到这样的效果, 我们需要使用接口和抽象类等.

### 单一职责原则(Single Responsibility Principle)

> 一个类应该只有一个发生变化的原因.

不要存在多于一个导致类变更的原因, 也就是说每个类应该实现单一的职责, 否则就应该把类拆分.

### 里氏替换原则(Liskov Substitution Principle)

> 所有引用基类的地方必须能透明地使用其子类的对象.

任何基类可以出现的地方, 子类一定可以出现. 里氏替换原则是继承复用的基石, 只有当衍生类可以替换基类, 软件单位的功能不受到影响时, 基类才能真正被复用, 而衍生类也能够在基类的基础上增加新的行为.

里氏代换原则是对"开-闭"原则的补充. 实现"开闭"原则的关键步骤就是抽象化. 而基类与子类的继承关系就是抽象化的具体实现, 所以里氏替换原则是对实现抽象化的具体步骤的规范. 里氏替换原则中, 子类对父类的方法尽量不要重写和重载. 因为父类代表了定义好的结构, 通过这个规范的接口与外界交互, 子类不应该随便破坏它.

### 依赖倒置原则(Dependence Inversion Principle)

> 上层模块不应该依赖底层模块, 它们都应该依赖于抽象.
>
> 抽象不应该依赖于细节, 细节应该依赖于抽象.

面向接口编程, 依赖于抽象而不依赖于具体. 写代码时用到具体类时, 不与具体类交互, 而与具体类的上层接口交互.

### 接口隔离原则(Interface Segregation Principle)

> 客户端不应该依赖它不需要的接口.
>
> 类间的依赖关系应该建立在最小的接口上.

每个接口中不存在子类用不到却必须实现的方法, 如果不然, 就要将接口拆分. 使用多个隔离的接口, 比使用单个接口(多个接口方法集合到一个的接口)要好.

### 迪米特法则(最少知道原则)(Law of Demeter)

> 只与你的直接朋友交谈, 不跟"陌生人"说话.

一个类对自己依赖的类知道的越少越好. 无论被依赖的类多么复杂, 都应该将逻辑封装在方法的内部, 通过 public 方法提供给外部. 这样当被依赖的类变化时, 才能最小的影响该类.

最少知道原则的另一个表达方式是: 只与直接的朋友通信. 类之间只要有耦合关系, 就叫朋友关系. 耦合分为依赖, 关联, 聚合, 组合等. 我们称出现为成员变量, 方法参数, 方法返回值中的类为直接朋友. 局部变量, 临时变量则不是直接的朋友. 我们要求陌生的类不要作为局部变量出现在类中.

### 合成复用原则(Composite Reuse Principle)

> 尽量使用对象组合/聚合, 而不是继承关系达到软件复用的目的.

合成或聚合可以将已有对象纳入到新对象中, 使之成为新对象的一部分, 因此新对象可以调用已有对象的功能.

## Menus

- 创建型

  - [单例模式](./docs/Singleton.md): 确保一个类仅有一个实例, 并提供一个访问它的全局访问点.

  - [原型模式](./docs/Prototype.md): 用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象.

  - [建造者模式](./docs/Builder.md): 又叫生成器模式, 它将一个复杂的构建与其表示相分离, 使得同样的构建过程可以创建不同的表示.

  - [工厂模式](./docs//Factory.md): 定义一个创建对象的接口, 让其子类自己决定实例化哪一个工厂类, 工厂模式使其创建过程延迟到子类进行.

  - [抽象工厂模式](./docs/AbstractFactory.md): 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们具体的类.

- 结构型

  - [装饰器模式](./docs/Decorator.md): 又叫包装(Wrapper)模式, 它以对客户端透明的方式拓展对象的功能, 是继承关系的一种替代方案.

  - [代理模式](./docs/Proxy.md): 代理模式是为一个对象提供一个代用品或占位符, 以便控制对它的访问.

  - [享元模式](./docs/Flyweight.md): 享元模式的核心是运用共享技术来有效支持大量细粒度的对象.

  - [适配器模式](./docs/Adapter.md): 将一个类的接口转换成客户希望的另外一个接口. 适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作.

  - [组合模式](./docs/Composite.md): 组合模式将对象组合成树形结构, 以表示"部分 - 整体"的层次结构.

  - [外观模式](./docs/Facade.md): 隐藏系统的复杂性, 并向客户端提供了一个客户端可以访问系统的接口.

  - [桥接模式](./docs/Bridge.md): 又称柄体(Handle and Body)模式或接口(Interface)模式. 将抽象部分与实现部分分离, 使它们都可以独立的变化.

- 行为型

  - [策略模式](./docs/Strategy.md): 定义一系列算法, 把它们一个个封装起来, 并且使它们可以互相替换.

  - [职责链模式](./docs/ChainOfResponsibility.md): 使多个对象都有机会处理请求, 从而避免请求的发送者和接收者之间的耦合关系, 将这些对象连成一条链, 并沿着这条链传递该请求, 直到有一个对象处理它为止.

  - [迭代器模式](./docs/Iterator.md): 迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素, 而又不需要暴露该对象的内部表示.

  - [命令模式](./docs/Command.md): 将一个请求封装为一个对象, 从而使我们可用不同的请求对客户进行参数化; 对请求排队或者记录请求日志, 以及支持可撤销的操作.

  - [发布-订阅模式(观察者模式)](./docs/Observable.md): 观察者模式定义对象间的一种一对多的依赖关系, 当一个对象的状态发生改变时, 所有依赖于它的对象都将得到通知.

  - [模版方法模式](./docs/TemplateMethod.md): 模版方法模式基于继承, 需要提供一个抽象类, 然后让子类继承.

  - [中介者模式](./docs/Mediator.md): 用于解除对象与对象之间的紧耦合关系, 增加一个中介者对象, 所有的相关对象都通过中介者对象来通信, 而不是互相引用, 当一个对象发生改变时, 只需要通知中介者对象即可.

  - [状态模式](./docs/State.md): 允许一个对象在其内部状态改变时改变它的行为, 对象看起来似乎修改了它的类.

  - [备忘录模式](./docs/Memento.md): 保存一个对象的某个状态, 以便在适当的时候恢复对象.

  - [访问者模式](./docs/Visitor.md): 主要解决稳定的数据结构和易变的操作耦合问题.

  - [解释器模式](./docs/Interpreter.md): 给定一个语言, 定义它的文法表示, 并定义一个解释器, 这个解释器使用该标识来解释语言中的句子.

## License

Design Patterns is [MIT licensed](https://opensource.org/licenses/MIT).
